<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HTML的常用布局方式</title>
      <link href="2021/04/16/Vue%E4%B8%8EReact%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>2021/04/16/Vue%E4%B8%8EReact%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的页面布局方式有，"><a href="#常见的页面布局方式有，" class="headerlink" title="常见的页面布局方式有，"></a>常见的页面布局方式有，</h2><ul><li><strong>静态布局</strong> px布局</li><li><strong>流式布局（Liquid Layout）</strong> 主要的划分区域的尺寸使用百分数（搭配min-*、max-*属性使用）</li><li><strong>自适应布局（Adaptive Layout）</strong> 即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围</li><li><strong>响应式布局（Responsive Layout）</strong> 检测窗口大小利用bootstrap布局</li><li><strong>弹性布局（rem/em布局）</strong> css3 rem</li></ul><blockquote><p><strong>结论提前说：</strong></p><ol><li>如果只做pc端，那么静态布局（定宽度）是最好的选择；</li><li>如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份css+一份js调节font-size搞定；</li><li>如果pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局。</li></ol></blockquote><h2 id="一、静态布局（Static-Layout）"><a href="#一、静态布局（Static-Layout）" class="headerlink" title="一、静态布局（Static Layout）"></a><strong>一、静态布局（Static Layout）</strong></h2><p>即传统Web设计，网页上的所有元素的尺寸一律使用px作为单位。</p><p><strong>1、布局特点：</strong>不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见与pc端。<br><strong>2、设计方法：</strong><br>　　<strong>PC：</strong>居中布局，所有样式使用绝对宽度/高度(px)，设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；<br>　　<strong>移动设备：</strong>另外建立移动网站，单独设计一个布局，使用不同的域名如wap.或m.。</p><p>　  <strong>在移动端开发中采用静态布局的两种方式：(来自：<a href="https://www.zhihu.com/question/21679928">流布局与响应式网页设计有什么区别？</a>)</strong></p><p>　（1）在viewport meta标签上设置width=320，页面的各个元素也采用px作为单位。通过用JS动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。（见<a href="https://link.zhihu.com/?target=http://www.520ued.com/article/549125815f85b6b44ca20b2b">前端开发-web app 变革之rem</a>）</p><p>　（2）设在viewport meta标签上设置content”width=640,user-scalable=no，页面的各个元素也采用px作为单位。由于640px超出了手机宽度，浏览器会自动缩小页面至刚好全屏。（具体见<a href="https://www.zhihu.com/question/32090605">content”width=640,user-scalable=no” 然后再进行固定尺寸的px设计？ - 前端开发</a>）</p><p><strong>优点：</strong>这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。</p><p><strong>缺点：</strong>显而易见，即不能根据用户的屏幕尺寸做出不同的表现。</p><p>当前，大部分门户网站、大部分企业的PC宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。</p><h2 id="二、流式布局（Liquid-Layout）"><a href="#二、流式布局（Liquid-Layout）" class="headerlink" title="二、流式布局（Liquid Layout）"></a><strong>二、流式布局（Liquid Layout）</strong></h2><p>流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。</p><p>网页中主要的划分区域的尺寸使用百分数（搭配min-*、max-*属性使用），例如，设置网页主体的宽度为80%，min-width为960px。图片也作类似处理（width:100%, max-width一般设定为图片本身的尺寸，防止被拉伸而失真）。</p><p><strong>1、布局特点：</strong>屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示】</p><p><strong>2、设计方法：</strong>使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。</p><p><strong>这种布局方式在Web前端开发的早期历史上，用来应对不同尺寸的PC屏幕</strong>（那时屏幕尺寸的差异不会太大），<strong>在当今的移动端开发也是常用布局方式</strong>，但<strong>缺点明显</strong>：<strong>主要的问题</strong>是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。</p><h2 id="三、自适应布局（Adaptive-Layout）"><a href="#三、自适应布局（Adaptive-Layout）" class="headerlink" title="三、自适应布局（Adaptive Layout）"></a><strong>三、自适应布局（Adaptive Layout）</strong></h2><p>自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个系列。<br>1、布局特点：屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。<br>2、设计方法：使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。</p><h2 id="四、响应式布局（Responsive-Layout）"><a href="#四、响应式布局（Responsive-Layout）" class="headerlink" title="四、响应式布局（Responsive Layout）"></a><strong>四、响应式布局（Responsive Layout）</strong></h2><p>随着CSS3出现了<strong>媒体查询</strong>技术，又出现了<strong>响应式设计</strong>的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出令人满意的效果，对CSS编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。</p><p>响应式几乎已经成为优秀页面布局的标准。</p><p><strong>1、布局特点：</strong>每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。</p><p><strong>2、设计方法：</strong>媒体查询+流式布局。通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。</p><p><strong>优点：</strong>适应pc和移动端，如果足够耐心，效果完美</p><p><strong>缺点：</strong>（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。</p><p><strong>总结：</strong></p><p>响应式与自适应的原理是相似的，都是检测设备，根据不同的设备采用不同的css，而且css都是采用的百分比的，而不是固定的宽度，不同点是响应式的模板在不同的设备上看上去是不一样的，会随着设备的改变而改变展示样式，而自适应不会，所有的设备看起来都是一套的模板，不过是长度或者图片变小了，不会根据设备采用不同的展示样式，流式就是采用了一些设置，当宽度大于多少时怎么展示，小于多少时怎么展示，而且展示的方式向水流一样，一部分一部分的加载，静态的就是采用固定宽度的了。</p><p>流式布局是用于解决类似的设备不同分辨率之间的兼容(一般分辨率差异较少)；响应式是用于解决不用设备之间不用分辨率之间的兼容问题(一般是指PC，平板，手机等设备之间较大的分辨率差异)。</p><p>如何实现响应式布局：<a href="http://caibaojian.com/356.html">折腾响应式布局设计</a>，<a href="http://www.zhangxinxu.com/wordpress/2011/09/%E9%A1%B5%E9%9D%A2%E5%93%8D%E5%BA%94%E5%B8%83%E5%B1%80/">应运而生的web页面响应布局</a></p><h2 id="五、弹性布局（rem-em布局）"><a href="#五、弹性布局（rem-em布局）" class="headerlink" title="五、弹性布局（rem/em布局）"></a><strong>五、</strong>弹性布局（rem/em布局）</h2><p>参考：<a href="https://www.zhihu.com/question/21679928">流布局与响应式网页设计有什么区别？</a></p><p><strong>1、rem,em区别：</strong>rem,em都是顺应不同网页字体大小展现而产生的。其中，em是相对其父元素，在实际应用中相对而言会带来很多不便；而rem是始终相对于html大小，即页面根元素。</p><p>2、使用 em 或 rem 单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示，因为em是相对父级元素的原因没有得到推广。【中国站点制作网页的时候，习惯用CSS强制定义字体大小，保证每个人都看到一致的效果，包括网易、搜狐这些门户网站在内的大部分站点，用的都是绝对单位px（像素）。但是，如果从网站<strong>易用性</strong>方面考虑，字体大小应该是可变的，一些视力不是那么好的人需要放大字体才能看得清页面内容。然而，占据大部分浏览器市场的IE无法调整那些使用px作为单位的字体大小。国外人士非常重视网站的易用性，相当一部分外国站点已经使用em作为字体单位。】</p><p>3、这类布局的特点是，<strong>包裹文字的各元素的尺寸采用em/rem做单位，而页面的主要划分区域的尺寸仍使用百分数或px做单位（同「流式布局」或「静态/固定布局」）</strong>。<strong>早期浏览器不支持整个页面按比例缩放</strong>，仅支持网页内文字尺寸的放大，这种情况下。使用em/rem做单位，可以使包裹文字的元素随着文字的缩放而缩放。</p><p>4、浏览器的默认字体高度一般为<code>16px</code>，即1em:16px，但是 1:16 的比例不方便计算，为了使单位em/rem更直观，CSS编写者常常将页面跟节点字体设为62.5%，比如选择用rem控制字体时，先需要设置根节点html的字体大小，因为浏览器默认字体大小16px*62.5%=10px。这样1rem便是10px，方便了计算。</p><p>Set body font-size to 62.5% for Easier em Conversion:</p><p>If you would like to use relative units (em) for your font sizes, declaring 62.5% for the font-size property of the body will make it easier to convert px to em. By doing it this way, converting to em is a matter of dividing the px value by 10 (e.g. 24px = 2.4em).</p><p>那么为什么一般多是 html{font-size:62.5%;} 而不是 html{font-size:10px;}呢？</p><p>因为有些浏览器默认的不是16px，或者用户修改了浏览器默认的字体大小（因浏览器分辨率大小，视力，习惯等因素）。如果我们将其设置为10px，一定会影响在这些浏览器上的效果，所以最好用绝大多数用户默认的16作为基数 * 62.5% 得到我们需要的10px。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html &#123;font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/&#125;</span><br><span class="line">body &#123;font-size: 1.4rem;/*1.4 × 10px = 14px */&#125;</span><br><span class="line">h1 &#123; font-size: 2.4rem;/*2.4 × 10px = 24px*/&#125;</span><br></pre></td></tr></table></figure><p>实际项目设置成 font-size: 62.5%可能会出现问题，因为chrome不支持小于12px的字体，计算小于12px的时候，会默认取12px去计算，导致chrome的em/rem计算不准确。</p><p>针对这个现象，可以尝试设置html字体为100px，body 修正为16px，这样 0.1rem 就是 10px，而body的字体仍然是默认大小，不影响未设置大小的元素的默认字体的大小。</p><p><strong>5、</strong>用em/rem定义尺寸的另一个好处是更能适应缩进/以字体单位padding或margin／浏览器设置字体尺寸等情况（因为em/rem相对于字体大小，会同步改变）。例如：p{ text-indent: 2em; }</p><p><strong>6、使用rem单位的弹性布局****在移动端也很受欢迎</strong>。</p><p><strong>工具ViewtoREM****：</strong>PX转换到REM（自动预处理）<br>*<em>rem***</em>的定义：*<em>font size of the root element，*<em>*<em>rem是相对于根元素<html>来设置字体大小的，这就意味着，我们只需要根据自己的需求在根元素确定一个参考值。<br><strong>rem</strong></em>*与em</em>**</em>、px<strong><strong>的区别：</strong><br>px：像素，比较精确的单位，但不好做响应式布局<br>em：以父节点font-size大小为参考点，标准不统一，容易造成混乱<br><strong>REM</strong></strong>支持的浏览器：**Mozilla Firefox 3.6+、Apple Safari 5+、Google Chrome、IE9+和Opera11+。IE6-8无法支持。</p><p>对于不同尺寸的屏幕，可以统一假设屏幕宽度为640px后编写CSS（当然你也可以假定统一为320px）。此时，我们设定html元素的font-size为40px（同样，只是举例），然后各处（元素尺寸、文字大小）使用rem作为单位，随后搭配媒体查询或JS，<strong>根据屏幕的大小来动态控制html元素的font-size</strong>（特定屏幕尺寸下，html元素的font-size应当设置为何值，是使用这个方案时设计师和程序员需要反复考虑后确定的，以下试举一段相关的CSS媒体查询代码），<strong>即可自动改变所有用rem定义尺寸的元素的大小</strong>（且CSS编写者在脑中进行换算的计算过程比em简单得多）。</p><p><img src= "/img/loading.gif" data-lazy-src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="img"> View Code</p><p><strong>其实在移动端使用所谓的弹性布局，是比较勉强的</strong>。移动端弹性布局流行起来的原因归根结底是rem单位对于（根据屏幕尺寸）调整页面的各元素的尺寸、文字大小时比较好用。其实，使用vw、vh等后起之秀的单位，可以实现完美的流式布局（高度和文字大小都可以变得“流式”），弹性布局就不再必要了。详细可参考：<a href="http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/">视区相关单位vw, vh..简介以及可实际应用场景</a></p><p>以下优缺点参考：<a href="http://www.qdfuns.com/notes/31064/97832917559868ff15413d543ee06773.html">响应式设计和REM布局的对比</a>（有疑问）</p><p>优点：理想状态是所有屏幕的高宽比和最初的设计高宽比一样，或者相差不多，完美适应。</p><p>缺点：这种rem+js只不过是宽度自适应，高度没有做到自适应，一些对高度，或者元素间距要求比较高的设计，则这种布局没有太大的意义。如果只是宽度自适应，更推荐响应式设计。</p><p><strong>响应式和弹性布局之间的对比：</strong></p><p>响应式布局：改变浏览器宽度，“布局”会随之变化，不是一成不变的，例如导航栏在大屏幕下是横排，在小屏幕下是竖排，在超小屏幕下隐藏为菜单，也就是说如果有足够的耐心，在每一种屏幕下都应该有合理的布局，完美的效果。</p><p>rem布局：改变浏览器宽度，页面所有元素的高宽都等比例缩放，也就是大屏幕下导航是横的，小屏幕下还是横的只不过变小了。</p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise 对象</title>
      <link href="2021/04/11/Promise%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/04/11/Promise%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><blockquote><p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败)及其结果值。</p></blockquote><blockquote><p>若想了解 promises 的工作方式以及如何使用它们，我们建议您先阅读<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用 promises</a></p></blockquote><h3 id="Promise对象有以下两个特点。"><a href="#Promise对象有以下两个特点。" class="headerlink" title="Promise对象有以下两个特点。"></a><code>Promise</code>对象有以下两个特点。</h3><ul><li><p>对象的状态不受外界影响。</p><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p><p>Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。</p><p>如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建的一个 new 的 Promise</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="comment">//做一些异步操作</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;执行完成Promise&#x27;</span>);</span><br><span class="line">resolve(<span class="string">&#x27;要返回的数据可以任何数据例如接口返回数据&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//其执行过程是：执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。</span></span><br></pre></td></tr></table></figure><ul><li>注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当放在函数里面的时候只有调用的时候才会被执行。</span></span><br><span class="line">&lt;div onClick=&#123;promiseClick&#125;&gt;开始异步请求&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> promiseClick =<span class="function">()=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;点击方法被调用&#x27;</span>)</span><br><span class="line"> <span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="comment">//做一些异步操作</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;执行完成Promise&#x27;</span>);</span><br><span class="line">resolve(<span class="string">&#x27;要返回的数据可以任何数据例如接口返回数据&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">        <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。接下来就可以用Promise对象上有then、catch方法了，这就是Promise的强大之处了，看下面的代码：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promiseClick().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="comment">//后面可以用传过来的数据做些其他操作</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 先是方法被调用起床执行了promise,最后执行了promise的then方法，then方法是一个函数接受一个参数是接受resolve返回的数据这事就输出了‘要返回的数据可以任何数据例如接口返回数据’</span></span><br></pre></td></tr></table></figure><h3 id="Promise的精髓在于-："><a href="#Promise的精髓在于-：" class="headerlink" title="Promise的精髓在于 ："></a><code>Promise</code>的精髓在于 ：</h3><ul><li> Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。 </li></ul><p> 使用Promise的正确场景是这样的： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">promiseClick()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> runAsync3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。</span></span><br></pre></td></tr></table></figure><h3 id="Promise的reject用法-："><a href="#Promise的reject用法-：" class="headerlink" title="Promise的reject用法 ："></a><code>Promise</code>的<code>reject</code>用法 ：</h3><ul><li><p>以上是对promise的resolve用法进行了解释，相当于resolve是对promise成功时候的回调，它把promise的状态修改为fullfiled，那么，reject就是失败的时候的回调，他把promise的状态修改为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;随机数生成的值：&#x27;</span>,num)</span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">resolve(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;数字太于10了即将执行失败回调&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> p</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">promiseClick().then(</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;resolved成功回调&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;成功回调接受的值：&#x27;</span>,data);</span><br><span class="line">&#125;, </span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;rejected失败回调&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;失败执行回调抛出失败原因：&#x27;</span>,reason);</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">//以上代码：调用promiseClick方法执行，2秒后获取到一个随机数，如果小于10，我们算成功，调用resolve修改Promise的状态为fullfiled。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。并将状态改成rejected</span></span><br></pre></td></tr></table></figure></li><li><p>运行promiseClick并且在then中传了两个参数，这两个参数分别是两个函数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。（也就是说then方法中接受两个回调，一个成功的回调函数，一个失败的回调函数，并且能在回调函数中拿到成功的数据和失败的原因），所以我们能够分别拿到成功和失败传过来的数据就有以上的运行结果。</p></li></ul><h3 id="catch的用法："><a href="#catch的用法：" class="headerlink" title="catch的用法："></a><code>catch</code>的用法：</h3><ul><li><p>与Promise对象方法then方法并行的一个方法就是catch,与try catch类似，catch就是用来捕获异常的，也就是和then方法中接受的第二参数rejected的回调是一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;随机数生成的值：&#x27;</span>,num)</span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">resolve(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;数字太于10了即将执行失败回调&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> p</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">promiseClick().then(</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;resolved成功回调&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;成功回调接受的值：&#x27;</span>,data);</span><br><span class="line"><span class="built_in">console</span>.log(noData);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason, data</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;catch到rejected失败回调&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;catch失败执行回调抛出失败原因：&#x27;</span>,reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>效果和写在then的第二个参数里面一样。它将大于10的情况下的失败回调的原因输出，但是，它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。</p></li><li><p>在resolve的回调中，我们console.log(noData);而noData这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到上图的结果，也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错</p></li></ul><h3 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法 :"></a><strong><code>all</code>的用法 :</strong></h3><ul><li> 与then同级的另一个方法，all方法，该方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后并且执行结果都是成功的时候才执行回调。</li><li>将上述方法复制两份并重命名promiseClick3(), promiseClick2(), promiseClick1() </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseClick1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;随机数生成的值：&#x27;</span>,num)</span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">resolve(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;数字太于10了即将执行失败回调&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> p</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">promiseClick2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;随机数生成的值：&#x27;</span>,num)</span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">resolve(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;数字太于10了即将执行失败回调&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> p</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">promiseClick3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;随机数生成的值：&#x27;</span>,num)</span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">resolve(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;数字太于10了即将执行失败回调&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> p</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.all([promiseClick3(), promiseClick2(), promiseClick1()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>Promise.all来执行，all接收一个数组参数，这组参数为需要执行异步操作的所有方法，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面，all会把所有异步操作的结果放进一个数组中传给then，然后再执行then方法的成功回调将结果接收，结果如下：（分别执行得到结果，all统一执行完三个函数并将值存在一个数组里面返回给then进行回调输出）这样以后就可以用all并行执行多个异步操作，并且在一个回调中处理所有的返回数据，比如你需要提前准备好所有数据才渲染页面的时候就可以使用all,执行多个异步操作将所有的数据处理好，再去渲染 </li></ul><h3 id="race的用法"><a href="#race的用法" class="headerlink" title="race的用法 :"></a><strong><code>race</code>的用法 :</strong></h3><ul><li><p>all是等所有的异步操作都执行完了再执行then方法，那么race方法就是相反的，谁先执行完成就先执行回调。先执行完的不管是进行了race的成功回调还是失败回调，其余的将不会再进入race的任何回调</p><p>我们将上面的方法延迟分别改成234秒</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseClick1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2s随机数生成的值：&#x27;</span>,num)</span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">resolve(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;2s数字太于10了即将执行失败回调&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> p</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">promiseClick2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;3s随机数生成的值：&#x27;</span>,num)</span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">resolve(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;3s数字太于10了即将执行失败回调&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> p</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">promiseClick3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">20</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4s随机数生成的值：&#x27;</span>,num)</span><br><span class="line"><span class="keyword">if</span>(num&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">resolve(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">reject(<span class="string">&#x27;4s数字太于10了即将执行失败回调&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">return</span> p</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Promise</span></span><br><span class="line">.race([promiseClick3(), promiseClick2(), promiseClick1()])</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;成功&#x27;</span>,results);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;失败&#x27;</span>,reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>当2s后promiseClick1执行完成后就已经进入到了then里面回调，在then里面的回调开始执行时，promiseClick2()和promiseClick3()并没有停止，仍旧再执行。于是再过3秒后，输出了他们各自的值，但是将不会再进入race的任何回调。如图2s生成10进入race的成功回调后，其余函数继续执行，但是将不会再进入race的任何回调，2s生成16进入了race的失败回调，其余的继续执行，但是将不会再进入race的任何回调。race的使用比如可以使用在一个请求在10s内请求成功的话就走then方法，如果10s内没有请求成功的话进入reject回调执行另一个操作。 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求某个table数据</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">requestTableList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">               <span class="comment">//去后台请求数据，这里可以是ajax,可以是axios,可以是fetch </span></span><br><span class="line">                resolve(res);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//延时函数，用于给请求计时 10s</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  reject(<span class="string">&#x27;请求超时&#x27;</span>);</span><br><span class="line">              &#125;, <span class="number">10000</span>);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.race([requestTableList(), timeout()]).then(<span class="function">(<span class="params">data</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//进行成功回调处理</span></span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">      &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 失败回调处理</span></span><br><span class="line">          <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>请求一个接口数据，10s内请求完成就展示数据，10s内没有请求完成就提示请求失败</p><p>这里定义了两个promise,一个去请求数据，一个记时10s，把两个promise丢进race里面赛跑去，如果请求数据先跑完就直接进入.then成功回调，将请求回来的数据进行展示；如果计时先跑完，也就是10s了数据请求还没有成功，就先进入race的失败回调，就提示用户数据请求失败进入.catch回调， 或者进入reject的失败回调，当.then里面没有写reject回调的时候失败回调会直接进入.catch 。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Promise </tag>
            
            <tag> 网络请求 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux状态管理</title>
      <link href="2021/04/02/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
      <url>2021/04/02/Redux%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p> <strong>学习文档</strong></p></blockquote><p>​    ⦁    英文文档: <a href="https://redux.js.org/">https://redux.js.org/</a></p><p>​    ⦁    中文文档: <a href="http://www.redux.org.cn/">http://www.redux.org.cn/</a></p><p>​    ⦁    Github: <a href="https://github.com/reactjs/redux">https://github.com/reactjs/redux</a></p><blockquote><p><strong>redux是什么</strong></p></blockquote><p>​    ⦁    redux是一个专门用于做状态管理的JS库(不是react插件库)。</p><p>​    ⦁    它可以用在react, angular, vue等项目中, 但基本与react配合使用。</p><p>​    ⦁    作用: 集中式管理react应用中多个组件共享的状态。</p><blockquote><p><strong>redux工作原理图</strong></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="/img/Redux.png"></p><blockquote><p><strong>redux的三个核心概念</strong></p></blockquote><h3 id="1-action"><a href="#1-action" class="headerlink" title="1. action"></a>1. action</h3><p>​    ⦁    动作的对象<br>​    ⦁    包含2个属性<br>​    ⦁    type：标识属性, 值为字符串, 唯一, 必要属性<br>​    ⦁    data：数据属性, 值类型任意, 可选属性<br>​    ⦁    例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_STUDENT&#x27;</span>,<span class="attr">data</span>:&#123;<span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-reducer"><a href="#2-reducer" class="headerlink" title="2. reducer"></a>2. reducer</h3><p>​    ⦁    用于初始化状态、加工状态。<br>​    ⦁    加工时，根据旧的state和action， 产生新的state的纯函数。</p><h3 id="3-store"><a href="#3-store" class="headerlink" title="3. store"></a>3. store</h3><p>​    ⦁    将state、action、reducer联系在一起的对象<br>​    ⦁    dispatch(action): 分发action, 触发reducer调用, 产生新的state<br>​    ⦁    subscribe(listener): 注册监听, 当产生了新的state时, 自动调用render()重新渲染页面</p><blockquote><p><strong>redux的试例</strong></p></blockquote><h3 id="1-创建一个store"><a href="#1-创建一个store" class="headerlink" title="1.创建一个store"></a>1.创建一个store</h3><ul><li>这里使用了一个加减算法的案例组件</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该文件专门用于暴露一个store对象，整个应用只有一个store对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//引入createStore，专门用于创建redux中最为核心的store对象</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">//引入为Count组件服务的reducer</span></span><br><span class="line"><span class="keyword">import</span> countReducer <span class="keyword">from</span> <span class="string">&#x27;./count_reducer&#x27;</span></span><br><span class="line"><span class="comment">//暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(countReducer)</span><br></pre></td></tr></table></figure><h3 id="2-创建对应的动作类型和data对象数据"><a href="#2-创建对应的动作类型和data对象数据" class="headerlink" title="2. 创建对应的动作类型和data对象数据"></a>2. 创建对应的动作类型和data对象数据</h3><ul><li>提前声明一个常量代替变量，方便避免在单词复杂情况下，敲错变量导致报错。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该模块是用于定义action对象中type类型的常量值，目的只有一个：便于管理的同时防止程序员单词写错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&#x27;increment&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">&#x27;decrement&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>在组件中给action传递类型和数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line">increment = <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;value&#125; = <span class="built_in">this</span>.selectNumber</span><br><span class="line">store.dispatch(createIncrementAction(value*<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line">decrement = <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;value&#125; = <span class="built_in">this</span>.selectNumber</span><br><span class="line">store.dispatch(createDecrementAction(value*<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在由action整理好数据传递给reducer</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">该文件专门为Count组件生成action对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT,DECREMENT&#125; <span class="keyword">from</span> <span class="string">&#x27;./constant&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createIncrementAction = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;<span class="attr">type</span>:INCREMENT,data&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createDecrementAction = <span class="function"><span class="params">data</span> =&gt;</span> (&#123;<span class="attr">type</span>:DECREMENT,data&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-创建对应组件功能的reducer"><a href="#3-创建对应组件功能的reducer" class="headerlink" title="3.创建对应组件功能的reducer"></a>3.创建对应组件功能的reducer</h3><ul><li>接收action的数据进行计算，最后将计算的结果保存回store</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">1.该文件是用于创建一个为Count组件服务的reducer，reducer的本质就是一个函数</span></span><br><span class="line"><span class="comment">2.reducer函数会接到两个参数，分别为：之前的状态(preState)，动作对象(action)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT,DECREMENT&#125; <span class="keyword">from</span> <span class="string">&#x27;./constant&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = <span class="number">0</span> <span class="comment">//初始化状态</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">countReducer</span>(<span class="params">preState=initState,action</span>)</span>&#123;</span><br><span class="line"><span class="comment">// console.log(preState);</span></span><br><span class="line"><span class="comment">//从action对象中获取：type、data</span></span><br><span class="line"><span class="keyword">const</span> &#123;type,data&#125; = action</span><br><span class="line"><span class="comment">//根据type决定如何加工数据</span></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> INCREMENT: <span class="comment">//如果是加</span></span><br><span class="line"><span class="keyword">return</span> preState + data</span><br><span class="line"><span class="keyword">case</span> DECREMENT: <span class="comment">//若果是减</span></span><br><span class="line"><span class="keyword">return</span> preState - data</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> preState</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-取出结果和再次渲染页面"><a href="#4-取出结果和再次渲染页面" class="headerlink" title="4 .取出结果和再次渲染页面"></a>4 .取出结果和再次渲染页面</h3><ul><li>可以通过**store.getState()**方法获得数据在reducer初始化的值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前求和为：&#123;store.getState()&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">ref</span>=<span class="string">&#123;c</span> =&gt;</span> this.selectNumber = c&#125;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.increment&#125;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.decrement&#125;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="symbol">&amp;nbsp;</span></span><br></pre></td></tr></table></figure><ul><li>可以在我们的根组件设置数据更新时渲染整个页面，当然因为虚拟DOM的diff算法，所以这样并不会因为渲染整个页面而降低性能。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./redux/store&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line"></span><br><span class="line">store.subscribe(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态管理 </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canvas画布</title>
      <link href="2021/03/31/canvas%E7%94%BB%E5%B8%83/"/>
      <url>2021/03/31/canvas%E7%94%BB%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>canvas元素用于在网页上绘制图形。</p><h2 id="什么是canvas"><a href="#什么是canvas" class="headerlink" title="什么是canvas"></a>什么是canvas</h2><p><strong>HTML5 canvas</strong> 元素用于图形的绘制，通过脚本(通常是JavaScript)来完成.</p><p><strong>canvas</strong>标签只是图形容器，您必须使用脚本来绘制图形。</p><p>你可以通过多种方法使用canvas绘制路径,盒、圆、字符以及添加图像。</p><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>表格中的数字表示支持<strong>canvas</strong>元素的第一个浏览器版本号。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/llqzc.png" alt="浏览器支持"></p><h2 id="创建一个画布（Canvas）"><a href="#创建一个画布（Canvas）" class="headerlink" title="创建一个画布（Canvas）"></a>创建一个画布（Canvas）</h2><p>一个画布在网页中是一个矩形框，通过<strong>canvas</strong>元素来绘制.</p><p>注意:默认情况下<strong>canvas</strong>元素没有边框和内容。</p><p>canvas简单实例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot;&gt;&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure><p>注意: 标签通常需要指定一个id属性 (脚本中经常引用), width 和 height 属性定义的画布的大小.</p><p>提示:你可以在HTML页面中使用多个 <strong>canvas</strong>元素.</p><p>使用 style 属性来添加边框:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot;</span><br><span class="line">style&#x3D;&quot;border:1px solid #000000;&quot;&gt;</span><br><span class="line">&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/canvas.png" alt="创建一个画布（Canvas）"></p><h2 id="使用JavaScript来绘制图像"><a href="#使用JavaScript来绘制图像" class="headerlink" title="使用JavaScript来绘制图像"></a>使用JavaScript来绘制图像</h2><p>canvas元素本身是没有绘图能力的。所有的绘制工作必须在JavaScript内部完成：</p><p>HTML代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot; style&#x3D;&quot;border:1px solid #c3c3c3;&quot;&gt;</span><br><span class="line">您的浏览器不支持 HTML5 canvas 标签。</span><br><span class="line">&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure><p>javascript代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line">ctx.fillStyle&#x3D;&quot;#FF0000&quot;;</span><br><span class="line">ctx.fillRect(0,0,150,75);</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/mycanvas.png" alt="使用JavaScript来绘制图像"></p><p><strong>实例解析:</strong></p><p>首先，找到<strong>canvas</strong>元素:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br></pre></td></tr></table></figure><p>然后，创建 context 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br></pre></td></tr></table></figure><p>getContext(“2d”) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p><p>下面的两行代码绘制一个红色的矩形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.fillStyle&#x3D;&quot;#FF0000&quot;;</span><br><span class="line">ctx.fillRect(0,0,150,75);</span><br></pre></td></tr></table></figure><p>设置fillStyle属性可以是CSS颜色，渐变，或图案。fillStyle 默认设置是#000000（黑色）。</p><p>fillRect(x,y,width,height) 方法定义了矩形当前的填充方式。</p><h2 id="Canvas-坐标"><a href="#Canvas-坐标" class="headerlink" title="Canvas 坐标"></a>Canvas 坐标</h2><p>canvas 是一个二维网格。</p><p>canvas 的左上角坐标为 (0,0)</p><p>上面的 fillRect 方法拥有参数 (0,0,150,75)。</p><p>意思是：在画布上绘制 150×75 的矩形，从左上角开始 (0,0)。</p><p>坐标实例</p><p>如下图所示，画布的 X 和 Y 坐标用于在画布上对绘画进行定位。鼠标移动的矩形框上，显示定位坐标。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/canvas.gif" alt="img"></p><h2 id="Canvas-路径"><a href="#Canvas-路径" class="headerlink" title="Canvas 路径"></a>Canvas 路径</h2><p>在Canvas上画线，我们将使用以下两种方法：</p><ul><li>moveTo(x,y)定义线条开始坐标</li><li>lineTo(x,y)定义线条结束坐标</li></ul><p>绘制线条我们必须使用到”ink”的方法，就像stroke().</p><p><strong>举例：</strong></p><p>定义开始坐标(0,0), 和结束坐标 (200,100)。然后使用 stroke() 方法来绘制线条:</p><p>HTML代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot; style&#x3D;&quot;border:1px solid #d3d3d3;&quot;&gt;</span><br><span class="line">您的浏览器不支持 HTML5 canvas 标签。&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure><p>javascript代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line">ctx.moveTo(0,0);</span><br><span class="line">ctx.lineTo(200,100);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/line.png" alt="在Canvas上画线"></p><p>在canvas中绘制圆形, 我们将使用以下javascript方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arc(&lt;i&gt;x&lt;&#x2F;i&gt;,&lt;i&gt;y&lt;&#x2F;i&gt;,&lt;i&gt;r&lt;&#x2F;i&gt;,&lt;i&gt;sAngle&lt;&#x2F;i&gt;,&lt;i&gt;eAngle&lt;&#x2F;i&gt;,&lt;i&gt;counterclockwise&lt;&#x2F;i&gt;);</span><br></pre></td></tr></table></figure><p><strong>参数值</strong></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>x</em></td><td align="left">圆的中心的 x 坐标。</td></tr><tr><td align="left"><em>y</em></td><td align="left">圆的中心的 y 坐标。</td></tr><tr><td align="left"><em>r</em></td><td align="left">圆的半径。</td></tr><tr><td align="left"><em>sAngle</em></td><td align="left">起始角，以弧度计。（弧的圆形的三点钟位置是 0 度）。</td></tr><tr><td align="left"><em>eAngle</em></td><td align="left">结束角，以弧度计。</td></tr><tr><td align="left"><em>counterclockwise</em></td><td align="left">可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。</td></tr></tbody></table><p><strong>定义和用法</strong></p><p>arc()方法创建弧/曲线（用于创建圆或部分圆）。</p><p>提示：如需通过arc()来创建圆，请把起始角设置为0，结束角设置为2*Math.PI。</p><p>提示：请使用stroke()或fill()方法在画布上绘制实际的弧。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/arc.gif" alt="arc()方法创建弧/曲线"></p><ul><li>中心：arc(100,75,50,0<em>Math.PI,1.5</em>Math.PI)</li><li>起始角：arc(100,75,50,0,1.5*Math.PI)</li><li>结束角：arc(100,75,50,0<em>Math.PI,1.5</em>Math.PI)</li></ul><p>实际上我们在绘制圆形时使用了 “ink” 的方法, 比如 stroke() 或者 fill().</p><p><strong>实例</strong></p><p>使用arc()方法绘制一个圆:</p><p>HTML代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot; style&#x3D;&quot;border:1px solid #d3d3d3;&quot;&gt;</span><br><span class="line">您的浏览器不支持 HTML5 canvas 标签。&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure><p>javascript代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line">ctx.beginPath();</span><br><span class="line">ctx.arc(95,50,40,0,2*Math.PI);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/arc.png" alt="使用arc()方法绘制一个圆:"></p><h2 id="Canvas-文本"><a href="#Canvas-文本" class="headerlink" title="Canvas-文本"></a>Canvas-文本</h2><p>使用canvas绘制文本，重要的属性和方法如下：</p><p>font-定义字体</p><p>fillText(<em>text,x,y,maxWidth</em>)-在canvas上绘制实心的文本</p><p>strokeText(<em>text,x,y,maxWidth</em>)-在canvas上绘制空心的文本</p><p><strong>参数值</strong></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>text</em></td><td align="left">规定在画布上输出的文本。</td></tr><tr><td align="left"><em>x</em></td><td align="left">开始绘制文本的 x 坐标位置（相对于画布）。</td></tr><tr><td align="left"><em>y</em></td><td align="left">开始绘制文本的 y 坐标位置（相对于画布）。</td></tr><tr><td align="left"><em>maxWidth</em></td><td align="left">可选。允许的最大文本宽度，以像素计。</td></tr></tbody></table><p><strong>使用fillText():</strong></p><p>实例</p><p>使用”Arial”字体在画布上绘制一个高30px的文字（实心）：</p><p>HTML代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot; style&#x3D;&quot;border:1px solid #d3d3d3;&quot;&gt;</span><br><span class="line">您的浏览器不支持 HTML5 canvas 标签。&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure><p>javascript代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line">ctx.font&#x3D;&quot;30px Arial&quot;;</span><br><span class="line">ctx.fillText(&quot;Hello World&quot;,10,50);</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/filltext.png" alt="使用&quot;Arial&quot;字体在画布上绘制一个高30px的文字（实心）"></p><p><strong>使用strokeText():</strong></p><p>实例</p><p>使用”Arial”字体在画布上绘制一个高30px的文字（空心）：</p><p>HTML代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;200&quot; height&#x3D;&quot;100&quot; style&#x3D;&quot;border:1px solid #d3d3d3;&quot;&gt;</span><br><span class="line">您的浏览器不支持 HTML5 canvas 标签。&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure><p>javascript代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line">ctx.font&#x3D;&quot;30px Arial&quot;;</span><br><span class="line">ctx.strokeText(&quot;Hello World&quot;,10,50);</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/stroketext.png" alt="使用 &quot;Arial&quot; 字体在画布上绘制一个高 30px 的文字（空心）"></p><h2 id="Canvas-渐变"><a href="#Canvas-渐变" class="headerlink" title="Canvas-渐变"></a>Canvas-渐变</h2><p>渐变可以填充在矩形,圆形,线条,文本等等,各种形状可以自己定义不同的颜色。</p><p>以下有两种不同的方式来设置Canvas渐变：</p><p>createLinearGradient()方法创建线性的渐变对象。</p><p>提示：请使用 addColorStop() 方法规定不同的颜色，以及在 gradient 对象中的何处定位颜色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">addColorStop()方法规定渐变对象中的颜色和位置。</span><br><span class="line"></span><br><span class="line">addColorStop()方法与createLinearGradient()或createRadialGradient()一起使用。</span><br><span class="line"></span><br><span class="line">注意：您可以多次调用addColorStop()方法来改变渐变。如果您不对渐变对象使用该方法，那么渐变将不可见。为了获得可见的渐变，您需要创建至少一个色标。</span><br><span class="line"></span><br><span class="line">JavaScript语法：gradient.addColorStop(stop,color);</span><br><span class="line"></span><br><span class="line">stop 介于0.0与1.0之间的值，表示渐变中开始与结束之间的位置。</span><br><span class="line"></span><br><span class="line">color 在stop位置显示的CSS颜色值。</span><br></pre></td></tr></table></figure><p>javascript语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createLinearGradient(x,y,x1,y1)</span><br></pre></td></tr></table></figure><p><strong>参数值</strong></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>x</em></td><td align="left">渐变开始点的 x 坐标</td></tr><tr><td align="left"><em>y</em></td><td align="left">渐变开始点的 y 坐标</td></tr><tr><td align="left"><em>x1</em></td><td align="left">渐变结束点的 x 坐标</td></tr><tr><td align="left"><em>y1</em></td><td align="left">渐变结束点的 y 坐标</td></tr></tbody></table><p>createLinearGradient() 方法创建放射状/圆形渐变对象。</p><p>JavaScript 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createRadialGradient(x0,y0,r0,x1,y1,r1);</span><br></pre></td></tr></table></figure><p><strong>参数值</strong></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>x0</em></td><td align="left">渐变的开始圆的 x 坐标</td></tr><tr><td align="left"><em>y0</em></td><td align="left">渐变的开始圆的 y 坐标</td></tr><tr><td align="left"><em>r0</em></td><td align="left">开始圆的半径</td></tr><tr><td align="left"><em>x1</em></td><td align="left">渐变的结束圆的 x 坐标</td></tr><tr><td align="left"><em>y1</em></td><td align="left">渐变的结束圆的 y 坐标</td></tr><tr><td align="left"><em>r1</em></td><td align="left">结束圆的半径</td></tr></tbody></table><p>实例</p><p>使用createLinearGradient()创建一个线性渐变。使用渐变填充矩形:</p><p>javascript代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create gradient</span><br><span class="line">var grd&#x3D;ctx.createLinearGradient(0,0,200,0);</span><br><span class="line">grd.addColorStop(0,&quot;red&quot;);</span><br><span class="line">grd.addColorStop(1,&quot;white&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Fill with gradient</span><br><span class="line">ctx.fillStyle&#x3D;grd;</span><br><span class="line">ctx.fillRect(10,10,150,80);</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/grd.png" alt="使用createLinearGradient()创建一个线性渐变"></p><p>实例</p><p>使用createRadialGradient()创建一个径向/圆渐变。使用渐变填充矩形：</p><p>javascript代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create gradient</span><br><span class="line">var grd&#x3D;ctx.createRadialGradient(75,50,5,90,60,100);</span><br><span class="line">grd.addColorStop(0,&quot;red&quot;);</span><br><span class="line">grd.addColorStop(1,&quot;white&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Fill with gradient</span><br><span class="line">ctx.fillStyle&#x3D;grd;</span><br><span class="line">ctx.fillRect(10,10,150,80);</span><br></pre></td></tr></table></figure><p>效果展示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.mybj123.com/wp-content/uploads/2018/09/grd2.png" alt="使用createRadialGradient()创建一个径向/圆渐变"></p><h2 id="Canvas-图像"><a href="#Canvas-图像" class="headerlink" title="Canvas 图像"></a>Canvas 图像</h2><p>把一幅图像放置到画布上, 使用以下方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drawImage(image,x,y)</span><br></pre></td></tr></table></figure><p>HTML代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Image to use:&lt;&#x2F;p&gt;</span><br><span class="line">&lt;img id&#x3D;&quot;scream&quot; src&#x3D;&quot;img_the_scream.jpg&quot; alt&#x3D;&quot;The Scream&quot; width&#x3D;&quot;220&quot; height&#x3D;&quot;277&quot;&gt;</span><br><span class="line">&lt;p&gt;Canvas:&lt;&#x2F;p&gt;</span><br><span class="line">&lt;canvas id&#x3D;&quot;myCanvas&quot; width&#x3D;&quot;250&quot; height&#x3D;&quot;300&quot; style&#x3D;&quot;border:1px solid #d3d3d3;&quot;&gt;</span><br><span class="line">您的浏览器不支持 HTML5 canvas 标签。</span><br><span class="line">&lt;&#x2F;canvas&gt;</span><br></pre></td></tr></table></figure><p>javascript代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var c&#x3D;document.getElementById(&quot;myCanvas&quot;);</span><br><span class="line">var ctx&#x3D;c.getContext(&quot;2d&quot;);</span><br><span class="line">var img&#x3D;document.getElementById(&quot;scream&quot;);</span><br><span class="line"></span><br><span class="line">img.onload &#x3D; function() &#123;</span><br><span class="line">    ctx.drawImage(img,10,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中computed和watch的用法和区别</title>
      <link href="2021/03/29/Vue%E4%B8%ADcomputed%E5%92%8Cwatch/"/>
      <url>2021/03/29/Vue%E4%B8%ADcomputed%E5%92%8Cwatch/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue的computed-计算属性-与watch-监听属性-的用法用途"><a href="#Vue的computed-计算属性-与watch-监听属性-的用法用途" class="headerlink" title="Vue的computed(计算属性)与watch(监听属性)的用法用途"></a>Vue的computed(计算属性)与watch(监听属性)的用法用途</h1><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><blockquote><p>computed在vue中起到<code>计算属性</code>作用。</p></blockquote><p><strong>用法</strong></p><p>HTML:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>firstName: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>lastName: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>name: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        firstName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        lastName: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"> </span><br><span class="line">computed: &#123;</span><br><span class="line">    name: &#123;</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">//set值触发</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.lastName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.firstName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">name</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.lastName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.firstName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是computed的基本用法。</p><p><strong>注意</strong>：<code>name</code>不能在data中声明</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><blockquote><p>watch在vue起到<code>观察监听</code>的作用</p></blockquote><p><strong>用法</strong></p><p>Vue模板：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    <span class="comment">//我们在getFullName方法中改变了name的值，触发watch打印&#x27;invoked watch&#x27;</span></span><br><span class="line">      &lt;p&gt;firstName: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;getFullName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">      &lt;p&gt;lastName: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;getFullName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">      &lt;p&gt;name: &#123;&#123;name&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            firstName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            lastName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    watch: &#123;</span><br><span class="line">        <span class="function"><span class="title">name</span>(<span class="params">newD, oldD</span>)</span> &#123;<span class="comment">//newD最新的值，oldD改变之前的值</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;invoked watch&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">getFullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="built_in">this</span>.lastName + <span class="built_in">this</span>.firstName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p> <strong>1.首次进入页面执行watch监听</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">      name: &#123;</span><br><span class="line">      <span class="function"><span class="title">handler</span>(<span class="params">newD, oldD</span>)</span> &#123;<span class="comment">//newD最新的值，oldD改变之前的值</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;invoked watch&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line">immediate: <span class="literal">true</span><span class="comment">//默认false(立即的、立刻)</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>加上immediate进入就会监听一次，打印<code>invoked watch</code></p><p><strong>2.监听对象(深度监听)</strong></p><p>下面这种情况，我们输入年龄的时候，watch是监听不到的，因为<code>改变的是person.age</code>而不是<code>person</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;p&gt;请输入年龄: <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.age&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">      &lt;p&gt;年龄: &#123;&#123;person.age&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            person: &#123;</span><br><span class="line">                age: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    watch: &#123;</span><br><span class="line">        person: &#123;</span><br><span class="line">            <span class="function"><span class="title">handler</span>(<span class="params">newD, oldD</span>)</span> &#123;<span class="comment">//newD最新的值，oldD改变之前的值</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;invoked watch&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>解决办法：</p><ul><li>给watch配置<code>deep</code>属性（添加deep这种属性性能会有所消耗，如果对象有很多属性也会监听）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    person: &#123;</span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newD, oldD</span>)</span> &#123;<span class="comment">//newD最新的值，oldD改变之前的值</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;invoked watch&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">deep: <span class="literal">true</span>   <span class="comment">//默认false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>监听你需要监听的属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    <span class="string">&quot;person.age&quot;</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newD, oldD</span>)</span> &#123;<span class="comment">//newD最新的值，oldD改变之前的值</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;invoked watch&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>3.监听路由</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">      <span class="string">&quot;$route.path&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">//可根据自己的需要判断当前路由的进入处理一些事情</span></span><br><span class="line">          <span class="function"><span class="title">handler</span>(<span class="params">newRouter, oldRouter</span>)</span> &#123;<span class="comment">//newD最新的路由路径值，oldD路由之前路径的值</span></span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">&#x27;invoked watch&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>computed</strong></p><ul><li><code>computed</code>适用于计算比较复杂中 </li><li><code>computed</code>在性能方面上比watch要好一点，因为具有缓存性</li><li><code>computed</code>是计算属性，所以更多用在数值计算的场景中 </li><li><code>computed</code>具有缓存性，之前get过的值之后会实惠缓存的，只有在它的依赖的属性值发生了变化，下次获取computed的值时才会重新调用对应的get重新计算</li></ul><p> <strong>watch</strong> </p><ul><li><code>watch</code>是监听观察的作用，类似于监听某些数据的回调，一般用于监听$emit/prop/data的值，当监听的数据发生改变做数据回调处理</li><li><code>watch</code>无缓存性，页面重新渲染时值不变化也会执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue与React的生命周期钩子</title>
      <link href="2021/03/24/Vue%E4%B8%8EReact%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/"/>
      <url>2021/03/24/Vue%E4%B8%8EReact%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一-vue的生命周期如下图所示-初始化、编译、更新、销毁"><a href="#一-vue的生命周期如下图所示-初始化、编译、更新、销毁" class="headerlink" title="一 vue的生命周期如下图所示    初始化、编译、更新、销毁"></a>一 vue的生命周期如下图所示    初始化、编译、更新、销毁</h1><p> <img src= "/img/loading.gif" data-lazy-src="/img/lifecycle-01.png" alt="img"></p><h1 id="二-vue生命周期的例子"><a href="#二-vue生命周期的例子" class="headerlink" title="二 vue生命周期的例子"></a>二 vue生命周期的例子</h1><p> 注意触发vue的created事件以后,this便指向vue实例,这点很重要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;vue生命周期&lt;&#x2F;title&gt;</span><br><span class="line">        &lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">        &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width,initial-scale&#x3D;1,minimum-scale&#x3D;1,maximum-scale&#x3D;1,user-scalable&#x3D;no&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;test&quot; style&#x3D;&quot;border: 1px black dashed;padding: 8px;&quot;&gt;</span><br><span class="line">            &#123;&#123;a&#125;&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;test2&quot; style&#x3D;&quot;border: 1px red solid;margin-top: 10px;padding: 8px;&quot;&gt;</span><br><span class="line">            我是内容二</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">            var myVue &#x3D; new Vue(&#123;</span><br><span class="line">                el: &quot;.test&quot;,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    a: &quot;我是内容,在控制台输入myVue.a&#x3D;123456,可以改变我的值&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                beforeCreate: function () &#123;</span><br><span class="line">                    console.log(&quot;建立前&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">                created: function () &#123; </span><br><span class="line">                    &#x2F;&#x2F;在实例创建之后同步调用。此时实例已经结束解析选项，这意味着已建立：数据绑定，计算属性，方法，watcher&#x2F;事件回调。</span><br><span class="line">                    &#x2F;&#x2F;但是还没有开始 DOM 编译，$el 还不存在,但是实例存在,即this.a存在,可打印出来 。</span><br><span class="line">                    console.log(&quot;建立&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">                beforeMount: function () &#123;</span><br><span class="line">                    console.log(&quot;渲染前&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">                mounted: function () &#123; </span><br><span class="line">                    console.log(&quot;渲染后&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">                beforeUpdate: function () &#123;  </span><br><span class="line">                    console.log(&quot;更新前&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">                updated: function () &#123; </span><br><span class="line">                    console.log(&quot;更新后&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">                beforeDestroy: function () &#123;  &#x2F;&#x2F;触发方式,在console里面打myVue.$destroy();</span><br><span class="line">                    &#x2F;&#x2F;在开始销毁实例时调用。此时实例仍然有功能。</span><br><span class="line">                    console.log(&quot;销毁前&quot;);</span><br><span class="line">                &#125;,</span><br><span class="line">                destroyed: function () &#123;   &#x2F;&#x2F;触发方式,在console里面打myVue.$destroy();其中myVue.$destroy(true)是删除DOM节点,会触发detached函数,但是实例仍然存在</span><br><span class="line">                    &#x2F;&#x2F;在实例被销毁之后调用。此时所有的绑定和实例的指令已经解绑，注意是解绑不是销毁,所有的子实例也已经被销毁。</span><br><span class="line">                    console.log(&quot;已销毁&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h1 id="一、react生命周期"><a href="#一、react生命周期" class="headerlink" title="一、react生命周期"></a>一、react生命周期</h1><p>React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁</p><p><img src= "/img/loading.gif" data-lazy-src="/img/lifecycle-02.jpg" alt="img"></p><ul><li><strong>初始化</strong></li></ul><p>1、getDefaultProps()</p><blockquote><p>设置默认的props，也可以用ufaultProps设置组件的默认属性.</p></blockquote><p>2、getInitialState()</p><blockquote><p>在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props</p></blockquote><p>3、componentWillMount()</p><blockquote><p>组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。</p></blockquote><p>4、 render()</p><blockquote><p>react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。</p></blockquote><p>5、componentDidMount()</p><blockquote><p>组件渲染之后调用，只调用一次。</p></blockquote><ul><li><strong>更新</strong></li></ul><p>6、componentWillReceiveProps(nextProps)</p><blockquote><p>组件初始化时不调用，组件接受新的props时调用。</p></blockquote><p>7、shouldComponentUpdate(nextProps, nextState)</p><blockquote><p>react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候</p></blockquote><p>8、componentWillUpdata(nextProps, nextState)</p><blockquote><p>组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state</p></blockquote><p>9、render()</p><blockquote><p>组件渲染</p></blockquote><p>10、componentDidUpdate()</p><blockquote><p>组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。</p></blockquote><ul><li><strong>卸载</strong></li></ul><p>11、componentWillUnmount()</p><blockquote><p>组件将要卸载时调用，一些事件监听和定时器需要在此时清除。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios请求与接收</title>
      <link href="2021/03/21/axios%E8%AF%B7%E6%B1%82/"/>
      <url>2021/03/21/axios%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="Axios是一个基于-promise-的-HTTP-库，可以用在浏览器和-node-js-中。"><a href="#Axios是一个基于-promise-的-HTTP-库，可以用在浏览器和-node-js-中。" class="headerlink" title="Axios是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。"></a><a href="http://axios-js.com/">Axios</a>是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</h2><h2 id="1-axios的基本使用"><a href="#1-axios的基本使用" class="headerlink" title="1. axios的基本使用"></a>1. axios的基本使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行npm进行axios的安装</span></span><br><span class="line">npm install axios</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认方式发送请求  默认情况下发送GET请求</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">axios(&#123;</span><br><span class="line">    url:<span class="string">&#x27;请求路径&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">            &#125;    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用GET 无参数 请求</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">axios(&#123;</span><br><span class="line">    url:<span class="string">&#x27;请求路径&#x27;</span>,</span><br><span class="line">    method:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">            &#125;    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用POST 无参数 请求</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">axios(&#123;</span><br><span class="line">    url:<span class="string">&#x27;请求路径&#x27;</span>,</span><br><span class="line">    method:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">            &#125;)    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="2-参数的传递方法"><a href="#2-参数的传递方法" class="headerlink" title="2.参数的传递方法"></a>2.参数的传递方法</h2><h4 id="1-以下为Get请求传参"><a href="#1-以下为Get请求传参" class="headerlink" title="1.以下为Get请求传参"></a>1.以下为Get请求传参</h4><p>方法①：在axios的url当中直接添加参数，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;?为分割路径和参数,id&#x3D;1 是需要传递的参数</span><br><span class="line">axios(&#123;</span><br><span class="line">    url:&#39;请求路径&#39;+&#39;?id&#x3D;1&#39;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方法②：在axios的params当中添加参数，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    url:&#39;请求路径&#39;,</span><br><span class="line">    params: &#123;</span><br><span class="line">    id:&#39;1&#39;,</span><br><span class="line">    name:&#39;张三&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-以下为Post请求传参"><a href="#2-以下为Post请求传参" class="headerlink" title="2.以下为Post请求传参"></a>2.以下为Post请求传参</h4><p>方法①：在axios的data中添加参数，例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下方法在后台控制器接收的name为nall。</span><br><span class="line">不过有三种解决方式：</span><br><span class="line">1.将data改为params。</span><br><span class="line">2.将内部键值对改为  &quot;name&#x3D;xxx&quot; 形式</span><br><span class="line">3.在服务器端给参数加上 @requestBody</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">    url:&#39;请求路径&#39;,</span><br><span class="line">    method:&#39;POST&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">    id:&#39;1&#39;,</span><br><span class="line">    name:&#39;张三&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-axios的简写"><a href="#3-axios的简写" class="headerlink" title="3.axios的简写"></a>3.axios的简写</h2><p>Get：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&#39;请求路径&#39;,&quot;name&#x3D;xxx&quot;).then(res)&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;请求成功后执行</span><br><span class="line">console.log(res);</span><br><span class="line">&#125;.catch(err&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;请求失败后执行</span><br><span class="line">console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Post：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.post(&#39;请求路径&#39;,&quot;name&#x3D;xxx&quot;).then(res)&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;请求成功后执行</span><br><span class="line">console.log(res);</span><br><span class="line">&#125;.catch(err&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;请求失败后执行</span><br><span class="line">console.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-axios的并发请求"><a href="#4-axios的并发请求" class="headerlink" title="4.axios的并发请求"></a>4.axios的并发请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过axios的spread方法处理响应数组的结果</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">axios.all([</span><br><span class="line">    axios.get(<span class="string">&#x27;请求1&#x27;</span>),</span><br><span class="line">axios.get(<span class="string">&#x27;请求2&#x27;</span>)</span><br><span class="line">]).then(</span><br><span class="line">    axios.spread(<span class="function">(<span class="params">res1,res2</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res1);</span><br><span class="line">                <span class="built_in">console</span>.log(res2);</span><br><span class="line">            &#125;)</span><br><span class="line">    ).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//请求失败后执行</span></span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="5-axios的全局配置"><a href="#5-axios的全局配置" class="headerlink" title="5.axios的全局配置"></a>5.axios的全局配置</h2><h4 id="1-全局配置下的网络请求"><a href="#1-全局配置下的网络请求" class="headerlink" title="1.全局配置下的网络请求"></a>1.全局配置下的网络请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过axios的spread方法处理响应数组的结果</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">axios.defaults.baseURL=<span class="string">&#x27;请求公用路径&#x27;</span>;</span><br><span class="line">axios.defaults.timeout=响应超时时间;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据默认请求配置，进行网络请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;请求的详细路径&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;);</span><br><span class="line">axios.post(<span class="string">&#x27;请求的详细路径&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="2-配合实例化配置使用更香哦！！！"><a href="#2-配合实例化配置使用更香哦！！！" class="headerlink" title="2.配合实例化配置使用更香哦！！！"></a>2.配合实例化配置使用更香哦！！！</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过axios的spread方法处理响应数组的结果</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> newVar = axios.create(&#123;</span><br><span class="line">        axios.defaults.baseURL=<span class="string">&#x27;请求公用路径&#x27;</span>,</span><br><span class="line">axios.defaults.timeout=响应超时时间</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newVar1 = axios.create(&#123;</span><br><span class="line">        axios.defaults.baseURL=<span class="string">&#x27;请求公用路径&#x27;</span>,</span><br><span class="line">axios.defaults.timeout=响应超时时间</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据默认请求配置，进行网络请求</span></span><br><span class="line">newVar(&#123;</span><br><span class="line">        url:<span class="string">&#x27;请求的详细路径&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">newVar1(&#123;</span><br><span class="line">        url:<span class="string">&#x27;请求的详细路径&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6. 拦截器"></a>6. 拦截器</h2><p><strong>主要作用于网络请求发起和响应的时候进行操作处理，</strong></p><p><strong>发起请求的时候可以添加网页加载的动画，对用户的登入进行强制。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//request(请求拦截器)response(响应拦截器)</span></span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">axios.interceptors.request 或者 response.use(<span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;请求路径&#x27;</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络请求 </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的PubSub机制</title>
      <link href="2021/03/18/React%E7%9A%84PubSub%E6%9C%BA%E5%88%B6/"/>
      <url>2021/03/18/React%E7%9A%84PubSub%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="React使用PubSub事件订阅，组件间通信"><a href="#React使用PubSub事件订阅，组件间通信" class="headerlink" title="React使用PubSub事件订阅，组件间通信"></a>React使用PubSub事件订阅，组件间通信</h1><h2 id="1-官网：https-github-com-mroderick-PubSubJS"><a href="#1-官网：https-github-com-mroderick-PubSubJS" class="headerlink" title="1.官网：https://github.com/mroderick/PubSubJS"></a>1.官网：<a href="https://github.com/mroderick/PubSubJS">https://github.com/mroderick/PubSubJS</a></h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>​    <a href="https://github.com/mroderick/PubSubJS">PubSub</a>，一个利用JavaScript进行发布/订阅的库，</p><p>为了方便在模块化开发当中进行各个模块的数据传递，所以引入了PubSub.js库。</p><h3 id="2-消息订阅与发布机制"><a href="#2-消息订阅与发布机制" class="headerlink" title="2.消息订阅与发布机制"></a>2.消息订阅与发布机制</h3><pre><code>               1.先订阅，再发布（理解：有一种隔空对话的感觉）              2.适用于任意组件间通信                        3.要在组件的componentWillUnmount中取消订阅</code></pre><h2 id="2-PubSub安装"><a href="#2-PubSub安装" class="headerlink" title="2.PubSub安装"></a>2.PubSub安装</h2><h3 id="1-下载依赖包"><a href="#1-下载依赖包" class="headerlink" title="1.下载依赖包"></a>1.下载依赖包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install pubsub-js </span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">yarn add pubsub-js</span><br></pre></td></tr></table></figure><h3 id="2-使用外链引用"><a href="#2-使用外链引用" class="headerlink" title="2.使用外链引用"></a>2.使用外链引用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.jsdelivr.com/#!pubsubjs</span></span><br><span class="line">https:<span class="comment">//cdnjs.com/libraries/pubsub-js</span></span><br><span class="line">https:<span class="comment">//unpkg.com/pubsub-js</span></span><br></pre></td></tr></table></figure><h3 id="3-在组件中导入"><a href="#3-在组件中导入" class="headerlink" title="3.在组件中导入"></a>3.在组件中导入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or when using CommonJS</span></span><br><span class="line"><span class="keyword">const</span> PubSub = <span class="built_in">require</span>(<span class="string">&#x27;pubsub-js&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="4-使用PubSub"><a href="#4-使用PubSub" class="headerlink" title="4.使用PubSub"></a>4.使用PubSub</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息发布：传递两个参数一个是接受函数的名字，一个给接受函数传递的参数</span></span><br><span class="line">  PubSub.publish(<span class="string">&#x27;fnName&#x27;</span>,data)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息订阅：函数接受  使用一个变量token去接收,传递两个参数，一个是定义的函数名字，一个是接收的函数（接收函数里面的msg可以忽略，data就是传递过来的值）；</span></span><br><span class="line"><span class="comment">//emmm，感觉和vuex有类似的地方</span></span><br><span class="line">   <span class="built_in">this</span>.token = PubSub.subscribe(<span class="string">&#x27;fnName&#x27;</span>, <span class="function">(<span class="params">msg, data</span>) =&gt;</span> &#123;</span><br><span class="line">             <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h3 id="5-案例"><a href="#5-案例" class="headerlink" title="5.案例"></a>5.案例</h3><p>​            在要使用的组件引入：**import PubSub from ‘pubsub-js’ ** ，然后在父组件的componentWillMount钩子进行消息的订阅。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">&#x27;./components/Bar&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      msg:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 订阅消息</span></span><br><span class="line">    PubSub.subscribe(<span class="string">&#x27;msg&#x27;</span>,<span class="function">(<span class="params">msg,data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        msg:data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;msg&#125; = <span class="built_in">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Bar/&gt;</span><br><span class="line">        &lt;p style=&#123;&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>&#125;&#125;&gt;我是订阅的结果：&#123;msg&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            在子组件/(兄弟组件)中进行发布消息，毕竟有了快递包裹的发件人，( •̀ ω •́ )y一定会有接受包裹的收件人。在这里我就以子组件为例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  sendMsg = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    PubSub.publish(<span class="string">&#x27;msg&#x27;</span>,<span class="string">`我是发布的随机数：<span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*<span class="number">1000</span>)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.sendMsg&#125;&gt;发布消息&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PubSub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
